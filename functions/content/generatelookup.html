<div class="row justify-content-center text-start">
    <div class="col-lg-8">
        <article>
            <h1 class="mb-4">Generate Lookup Tool</h1>
            <section class="mb-4">
                <p class="lead">In the realm of Retrieval Augmented Generation (RAG), managing text lookups for each vector is a critical task, but the approach can vary significantly. Unacog offers three distinct methods for handling text lookups, each tailored to different project scales and requirements.</p>
            </section>
            <figure class="text-center mb-5">
                <img src="https://firebasestorage.googleapis.com/v0/b/promptplusai.appspot.com/o/images%2Fgenerate%20lookup.png?alt=media&token=7261e495-4159-4e88-90bf-d24f22f8aadf" alt="Generate Lookup" class="img-fluid rounded">
                <figcaption class="figure-caption">Generate Lookup button in embed</figcaption>
            </figure>
            <section class="mb-4">
                <h2>1. Carrying Text in Metadata</h2>
                <p>A common practice, especially in smaller projects or demonstrations, is to carry the text directly within the metadata. This method is straightforward and illustrates the RAG technique effectively. However, its suitability wanes as projects scale. The primary concern here is cost-effectiveness; for example, Pinecone's vector database limits to 5 million vectors per pod/index, and metadata can quickly consume this space, particularly with large embedding models. This method, while convenient, is best reserved for projects with less stringent space requirements.</p>
            </section>
            
            <section class="mb-4">
                <h2>2. External Lookup Database</h2>
                <p>For projects not carrying text in metadata, an external lookup database becomes necessary. This is where Unacog's chunking and upserting process shines, creating a fetch map or a JSON file that maps each ID with its corresponding text and metadata. This approach is essential given that databases like Pinecone handle only metadata and vector sets. Opting not to store the full text in metadata is a cost-effective strategy, enabling efficient text retrieval based on vector similarity without the prohibitive expense of increased metadata storage.</p>
                <p>The creation of a comprehensive lookup database facilitates easy integration into various systems, offering full export capabilities and greater control over the data pipeline. This flexibility is invaluable, especially for applications requiring pre-loaded lookup data or those with specific data serving requirements.</p>
            </section>
            
            <section class="mb-4">
                <h2>3. Document-specific Fetch Map</h2>
                <p>Addressing scalability and loading speed, the third option on Unacog is particularly suited for handling vast datasets. By segmenting the fetch map by document, this method significantly reduces initialization times, eliminating the need to load the entire lookup at once. Utilized within Unacog's webapp for embedded messaging, this approach ensures that only relevant information is pulled down, storing loaded documents in cache for efficient access.</p>
            </section>
            
            <section class="pt-4 mt-4 border-top">
                <p class="text-muted">In conclusion, Unacog's Generate Lookup feature offers a range of solutions to the challenges of RAG, from simple metadata embedding to sophisticated, scalable fetch maps. These options cater to a variety of project sizes and complexities, allowing users to effectively and economically optimize their retrieval and generation processes.</p>
            </section>
        </article>
    </div>
</div>